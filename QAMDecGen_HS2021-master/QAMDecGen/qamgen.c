/*
* qamgen.c
*
* Created: 05.05.2020 16:24:59
*  Author: Chaos
*/ 
#include "avr_compiler.h"
#include "pmic_driver.h"
#include "TC_driver.h"
#include "clksys_driver.h"
#include "sleepConfig.h"
#include "port_driver.h"

#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "event_groups.h"
#include "semphr.h"
#include "stack_macros.h"

#include "mem_check.h"

#include "qaminit.h"
#include "qamgen.h"
#include "rtos_buttonhandler.h"


#define Symbol_00 0x10
#define Symbol_01 0x20
#define Symbol_10 0x40
#define Symbol_11 0x80

#define Data_ready 0x04

#define NR_OF_DATA_SAMPLES 8UL
#define DATABYTETOSENDMASK 0x1F

#define BUTTON1SHORTPRESSEDMASK     0x01
#define BUTTON2SHORTPRESSEDMASK     0x02

int16_t symbol_variante = 0;

// test sinus lookup table for 2 periods (=> 2 DMA Channels)
// 1 DMA channel sends data to DAC
// => second DMA channel refill with datas
// const sinus lookup table, do not use it, send idlebits instead
const int16_t sinLookup100[NR_OF_SAMPLES*2] = {	0x0,0x27,0x9c,0x159,0x258,0x38e,0x4f0,0x670,
												0x800,0x990,0xb10,0xc72,0xda8,0xea7,0xf64,0xfd9,
												0xFFF,0xfd9,0xf64,0xea7,0xda8,0xc72,0xb10,0x990,
												0x800,0x670,0x4f0,0x38e,0x258,0x159,0x9c,0x27,
												0x0,0x27,0x9c,0x159,0x258,0x38e,0x4f0,0x670,
												0x800,0x990,0xb10,0xc72,0xda8,0xea7,0xf64,0xfd9,
												0xFFF,0xfd9,0xf64,0xea7,0xda8,0xc72,0xb10,0x990,
												0x800,0x670,0x4f0,0x38e,0x258,0x159,0x9c,0x27};

/*
const lookup tables for all 4 symbols
00 => 100% Amplitude & Phaseshift	0°
01 => 100% Amplitude & Phaseshift  180°
10 =>  50% Amplitude & Phaseshift	0°
11 =>  50% Amplitude & Phaseshift  180°
MSB = Amplitude | LSB = Phaseshift
=> Generated by https://www.daycounter.com/Calculators/Sine-Generator-Calculator.phtml

calucalted offset offset
0x0,0x14,0x4e,0xad,0x12c,0x1c7,0x278,0x338,
0x400,0x4c8,0x588,0x639,0x6d4,0x753,0x7b2,0x7ec,
0x800,0x7ec,0x7b2,0x753,0x6d4,0x639,0x588,0x4c8,
0x400,0x338,0x278,0x1c7,0x12c,0xad,0x4e,0x14
=
0x400,0x414,0x44e,0x4ad,0x52c,0x5c1,0x678,0x738,
0x800,0x8c8,0x988,0xa39,0xad4,0xb53,0xbb2,0xbec,
0xc00,0xbec,0xbb2,0xb53,0xad4,0xa39,0x988,0x8c8,
0x800,0x738,0x678,0x5c1,0x52c,0x4ad,0x44e,0x414
*/

const int16_t Symbol_00_lookup[NR_OF_SAMPLES] = {	
											0x0,0x27,0x9c,0x159,0x258,0x38e,0x4f0,0x670,
											0x800,0x990,0xb10,0xc72,0xda8,0xea7,0xf64,0xfd9,
											0xFFF,0xfd9,0xf64,0xea7,0xda8,0xc72,0xb10,0x990,
											0x800,0x670,0x4f0,0x38e,0x258,0x159,0x9c,0x27,
											};
										
const int16_t Symbol_01_lookup[NR_OF_SAMPLES] = {	
											0xFFF,0xfd9,0xf64,0xea7,0xda8,0xc72,0xb10,0x990,
											0x800,0x670,0x4f0,0x38e,0x258,0x159,0x9c,0x27,
											0x0,0x27,0x9c,0x159,0x258,0x38e,0x4f0,0x670,
											0x800,0x990,0xb10,0xc72,0xda8,0xea7,0xf64,0xfd9,
											};

const int16_t Symbol_10_lookup[NR_OF_SAMPLES] = {	
											0x400,0x414,0x44e,0x4ad,0x52c,0x5c1,0x678,0x738,
											0x800,0x8c8,0x988,0xa39,0xad4,0xb53,0xbb2,0xbec,
											0xc00,0xbec,0xbb2,0xb53,0xad4,0xa39,0x988,0x8c8,
											0x800,0x738,0x678,0x5c1,0x52c,0x4ad,0x44e,0x414
											};	

const int16_t Symbol_11_lookup[NR_OF_SAMPLES] = {	
											0xc00,0xbec,0xbb2,0xb53,0xad4,0xa39,0x988,0x8c8,
											0x800,0x738,0x678,0x5c1,0x52c,0x4ad,0x44e,0x414,
											0x400,0x414,0x44e,0x4ad,0x52c,0x5c1,0x678,0x738,
											0x800,0x8c8,0x988,0xa39,0xad4,0xb53,0xbb2,0xbec
											};

// const Idle Bit's
const uint8_t Idle_bits_1 = 0b01;
const uint8_t Idle_bits_2 = 0b10;

// const Sync bits
const uint8_t Sync_bits = 0b11;

// test lenght bits
const uint8_t Length_bits[] = {01,00};
	
// flag to toggle idle bits	
volatile bool send_idle_bit_2 = false;
volatile bool New_datas_rdy = false;
volatile bool Datas_rdy	= false;
volatile uint8_t x = 0;

uint8_t DataToSend = 0;

// var to store protocoll symbols for queue
uint8_t protocoll_symbols[30] = {};
uint16_t SymbolCounter = 0;

volatile uint8_t	Rx_Symbol[30] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};	
uint8_t queue_sampels;


typedef enum {
	Idle_1,
	Idle_2,
	SyncByte,
	Length,
	Datas,
	Checksum	
} eProtokollStates;


//void vsendSymbol(void *pvParameters);


//TaskHandle_t xsendSymbol;


QueueHandle_t xQueueData;
QueueHandle_t xSymbolQueue;



void vQuamGen(void *pvParameters) {
	while(evDMAState == NULL) {
		vTaskDelay(3/portTICK_RATE_MS);
	}
	xEventGroupWaitBits(evDMAState, DMAGENREADY, false, true, portMAX_DELAY);
	
	
	xQueueData		= xQueueCreate(1, sizeof(uint8_t));
	xSymbolQueue	= xQueueCreate(10, sizeof(uint8_t)*30); 
	
	bool Datas_rdy_to_send = false;
	uint8_t DataSymbolToSend;
	uint8_t DataSymbolCounter;
	uint8_t LenghtSymbolCounter;
	uint8_t Data[NR_OF_DATA_SAMPLES +1] = {};
	
	eProtokollStates Protokoll = Idle_1;
	
	for(;;){
		
		vTaskDelay(100/portTICK_RATE_MS);
	}
	
}//

void fillBuffer(uint16_t buffer[NR_OF_SAMPLES]) {
	
	
	queue_sampels = uxQueueMessagesWaitingFromISR(xSymbolQueue);
	
	// check if some messages in queue are avaiable
	//(queue_sampels > 2 & send_idle_bit_2 == false) |
	if(  New_datas_rdy ){
		// fetch them		
		if(xQueueReceiveFromISR(xSymbolQueue, (void*)&Rx_Symbol[x],NULL ) == pdTRUE){	
			// if succesfully reset flag
			New_datas_rdy = false;	
			Datas_rdy = true;
		}
	}
	
	if(Datas_rdy & !send_idle_bit_2){
		switch(Rx_Symbol[x]){
			case 0b00000000:{
				for(int i = 0; i < NR_OF_SAMPLES;i++) {
						buffer[i] = Symbol_00_lookup[i];
					}
			break;
			}
			case 0b00000001:{
				for(int i = 0; i < NR_OF_SAMPLES;i++) {
					buffer[i] = Symbol_01_lookup[i];
				}
				break;
			}
			case 0b00000010:{
				for(int i = 0; i < NR_OF_SAMPLES;i++) {
					buffer[i] = Symbol_10_lookup[i];
				}
				break;
			}
			case 0b00000011:{
				for(int i = 0; i < NR_OF_SAMPLES;i++) {
					buffer[i] = Symbol_11_lookup[i];
				}
				break;
			}
				
		}// end switch
		if( x < SymbolCounter){
			x++;
		}
		else{
			Datas_rdy = false;
			x = 0;
		}
		
	}//
	// if no messages in queue, send idle bits, otherwise it will send allways "00" Symbol
	else{
		// toggle Idle bits
		if( !send_idle_bit_2){
			for(int i = 0; i < NR_OF_SAMPLES;i++) {
				buffer[i] = Symbol_01_lookup[i];				
			}
			send_idle_bit_2 = true;
		}
		else{
			for(int i = 0; i < NR_OF_SAMPLES;i++) {
				buffer[i] = Symbol_10_lookup[i];
			}			
			send_idle_bit_2 = false;
		}
	}// end if no messages in queue
}// end void fillbuffer


void vButtonTask(void *pvParameters) {
	initButtonHandler();
	setupButton(BUTTON1, &PORTF, 4, 1);
	setupButton(BUTTON2, &PORTF, 5, 1);
	setupButton(BUTTON3, &PORTF, 6, 1);
	setupButton(BUTTON4, &PORTF, 7, 1);
	
	uint8_t calc_symbol = 0b00;
	
	vTaskDelay(3000);
	
	for(;;) {
		// Button 1 send value 35
		// => sync (11), lenght (11) data (10 00 11)
		if(getButtonState(BUTTON1, true) == buttonState_Short){
			// first add sync symbol to queue
			protocoll_symbols[0] = Sync_bits;
			
			// add lenght symbol
			protocoll_symbols[1] = 0b11;
			
			// data
			protocoll_symbols[2] = 0b10;
			protocoll_symbols[3] = 0b00;
			protocoll_symbols[4] = 0b11;
			SymbolCounter = 4;
			
			// send complete protocoll to queue
			xQueueSend(xSymbolQueue, (void*) &protocoll_symbols, (TickType_t) 10);
			// may use semaphores instead of flags?
			New_datas_rdy = true;
			
		}
		
		if(getButtonState(BUTTON2, false) == buttonState_Short){
			// try4 auto mode, max 255
			// ft 132
			// 1000 0100 -> 10 00 01 00
			// sync - lenght	- data		- checksum
			//	11     01 00   10 00 01 00  tbd
			DataToSend = 132;
			
			
			// first add sync symbol to queue
			protocoll_symbols[0] = Sync_bits;
			// add lenght symbol
			// adjust lenght symbol, just for testing
			protocoll_symbols[1] = 0b01;
			protocoll_symbols[2] = 0b00;
			
			//data symbols
			calc_symbol = DataToSend>>6 & 0b11;
			protocoll_symbols[3] = calc_symbol;
			calc_symbol = DataToSend>>4 & 0b11;
			protocoll_symbols[4] = calc_symbol;
			calc_symbol = DataToSend>>2 & 0b11;
			protocoll_symbols[5] = calc_symbol;
			calc_symbol = DataToSend & 0b11;
			protocoll_symbols[6] = calc_symbol;
			
			// checksum
			
			
			//symbol length
			SymbolCounter = 6;
			// send complete protocoll to queue
			xQueueSend(xSymbolQueue, (void*) &protocoll_symbols, (TickType_t) 10);
			New_datas_rdy=true;
		}
		vTaskDelay(10/portTICK_RATE_MS);
	}
}



ISR(DMA_CH0_vect)
{
	//static signed BaseType_t test;	
	DMA.CH0.CTRLB|=0x10;
	fillBuffer(&dacBuffer0[0]);
}

ISR(DMA_CH1_vect)
{
	DMA.CH1.CTRLB|=0x10;
	fillBuffer(&dacBuffer1[0]);
}

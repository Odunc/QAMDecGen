/*
* qamgen.c
*
* Created: 05.05.2020 16:24:59
*  Author: Chaos
*/ 
#include "avr_compiler.h"
#include "pmic_driver.h"
#include "TC_driver.h"
#include "clksys_driver.h"
#include "sleepConfig.h"
#include "port_driver.h"

#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "event_groups.h"
#include "semphr.h"
#include "stack_macros.h"

#include "mem_check.h"

#include "qaminit.h"
#include "qamgen.h"


int16_t symbol_variante = 0;

// test sinus lookup table for 2 periods (=> 2 DMA Channels)
// 1 DMA channel sends data to DAC
// => second DMA channel refill with datas
/*
const int16_t sinLookup100[NR_OF_SAMPLES*2] = {0x0,0x18F,0x30F,0x471,0x5A7,0x6A6,0x763,0x7D8,
												0x7FF,0x7D8,0x763,0x6A6,0x5A7,0x471,0x30F,0x18F,
												0x0,0xFE71,0xFCF1,0xFB8F,0xFA59,0xF95A,0xF89D,0xF828,
												0xF801,0xF828,0xF89D,0xF95A,0xFA59,0xFB8F,0xFCF1,0xFE71,
												0x0,0x18F,0x30F,0x471,0x5A7,0x6A6,0x763,0x7D8,
												0x7FF,0x7D8,0x763,0x6A6,0x5A7,0x471,0x30F,0x18F,
												0x0,0xFE71,0xFCF1,0xFB8F,0xFA59,0xF95A,0xF89D,0xF828,
												0xF801,0xF828,0xF89D,0xF95A,0xFA59,0xFB8F,0xFCF1,0xFE71};
												*/

const int16_t sinLookup100[NR_OF_SAMPLES*2] = {	0x0,0x27,0x9c,0x159,0x258,0x38e,0x4f0,0x670,
												0x800,0x990,0xb10,0xc72,0xda8,0xea7,0xf64,0xfd9,
												0xFFF,0xfd9,0xf64,0xea7,0xda8,0xc72,0xb10,0x990,
												0x800,0x670,0x4f0,0x38e,0x258,0x159,0x9c,0x27,
												0x0,0x27,0x9c,0x159,0x258,0x38e,0x4f0,0x670,
												0x800,0x990,0xb10,0xc72,0xda8,0xea7,0xf64,0xfd9,
												0xFFF,0xfd9,0xf64,0xea7,0xda8,0xc72,0xb10,0x990,
												0x800,0x670,0x4f0,0x38e,0x258,0x159,0x9c,0x27};

// Test arrays for all 4 symbols
// 00 => 100% Amplitude & Phaseshift	0°
// 01 => 100% Amplitude & Phaseshift  180°
// 10 =>  50% Amplitude & Phaseshift	0°
// 11 =>  50% Amplitude & Phaseshift  180°
// MSB = Amplitude | LSB = Phaseshift
// => Generated by https://www.daycounter.com/Calculators/Sine-Generator-Calculator.phtml
const int16_t Symbol_00[NR_OF_SAMPLES] = {	0x0,0x27,0x9c,0x159,0x258,0x38e,0x4f0,0x670,
											0x800,0x990,0xb10,0xc72,0xda8,0xea7,0xf64,0xfd9,
											0xFFF,0xfd9,0xf64,0xea7,0xda8,0xc72,0xb10,0x990,
											0x800,0x670,0x4f0,0x38e,0x258,0x159,0x9c,0x27,
											};
										
const int16_t Symbol_01[NR_OF_SAMPLES] = {	0xFFF,0xfd9,0xf64,0xea7,0xda8,0xc72,0xb10,0x990,
											0x800,0x670,0x4f0,0x38e,0x258,0x159,0x9c,0x27,
											0x0,0x27,0x9c,0x159,0x258,0x38e,0x4f0,0x670,
											0x800,0x990,0xb10,0xc72,0xda8,0xea7,0xf64,0xfd9,
											};

const int16_t Symbol_10[NR_OF_SAMPLES] = {	0x0,0x14,0x4e,0xad,0x12c,0x1c7,0x278,0x338,
											0x400,0x4c8,0x588,0x639,0x6d4,0x753,0x7b2,0x7ec,
											0x800,0x7ec,0x7b2,0x753,0x6d4,0x639,0x588,0x4c8,
											0x400,0x338,0x278,0x1c7,0x12c,0xad,0x4e,0x14
											};	

const int16_t Symbol_11[NR_OF_SAMPLES] = {	0x800,0x7ec,0x7b2,0x753,0x6d4,0x639,0x588,0x4c8,
											0x400,0x338,0x278,0x1c7,0x12c,0xad,0x4e,0x14,
											0x0,0x14,0x4e,0xad,0x12c,0x1c7,0x278,0x338,
											0x400,0x4c8,0x588,0x639,0x6d4,0x753,0x7b2,0x7ec,
											};





void vQuamGen(void *pvParameters) {
	while(evDMAState == NULL) {
		vTaskDelay(3/portTICK_RATE_MS);
	}
	xEventGroupWaitBits(evDMAState, DMAGENREADY, false, true, portMAX_DELAY);
	for(;;) {
		vTaskDelay(10/portTICK_RATE_MS);
	}
}

void fillBuffer(uint16_t buffer[NR_OF_SAMPLES]) {
	for(int i = 0; i < NR_OF_SAMPLES;i++) {
		//buffer[i] =  (sinLookup100[i]);
		// symbol0
		if(symbol_variante == 0){
			buffer[i] = Symbol_00[i];
		}
		// symbol 1
		if(symbol_variante == 1){
			buffer[i] = Symbol_01[i];
		}
		// symbol 2
		if(symbol_variante == 2){
			buffer[i] = Symbol_10[i];
		}
		// symbol 3
		if(symbol_variante == 3){
			buffer[i] = Symbol_11[i];
		}
	}
	if(symbol_variante == 3){
		symbol_variante = 0;
	}
	else {
		symbol_variante++;
	}
}

ISR(DMA_CH0_vect)
{
	//static signed BaseType_t test;
	
	DMA.CH0.CTRLB|=0x10;
	fillBuffer(&dacBuffer0[0]);
}

ISR(DMA_CH1_vect)
{
	DMA.CH1.CTRLB|=0x10;
	fillBuffer(&dacBuffer1[0]);
}